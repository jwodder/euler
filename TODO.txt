Code to focus on improving:
 - euler0023.py
 - euler0039.py
 - euler0044.py
 - euler0052.py
  - The code could stand to be more correct rather than only working because
    the answer isn't one of the possibilities it skips.
 - euler0072.py
 - euler0078.py
 - euler0092.py
 - euler0093.py
 - euler0095.py
 - euler0096.py
 - euler0112.py (cf. euler0113.py)
 - euler0124.py
 - euler0130.py
 - euler0145.c
 - euler0179.py
 - euler0204.py?
 - euler0205.py?
 - euler0206.py
 - euler0347.py

- Give aliquot() and totient() `presieve` arguments and the option to take a
  pre-computed factorization of `n` as an argument in addition to/instead of
  `n` itself
- Give primeIter() a `presieve` argument
- Use the new sieve algorithm in Primes.hs and eulerlib.cpp
- Stop using eulerlib/oldprimes.py
- Make factor() able to work without calling sieve() beforehand?
- Write a variant of/rewrite primeIter() so that primes are yielded as soon as
  sieve() finds them rather than waiting for sieve() to finish
- Rewrite euler0493.py in the vein of
  <http://math.stackexchange.com/q/1409280/10655> and/or using multivariate
  hypergeometric distributions
- Make generateAsc() support iterating only over unique values so that it can
  be used for euler0004.py
- Write Python versions of all non-Python solutions so that the latter can be
  deleted
- Write a generalized version of generateAsc() that takes a function $f$ and
  (finitely many) infinite sequences $\{a_i\}, \{b_j\}, \{c_k\}, \ldots$ such
  that increasing any of the indices in $f(a_i, b_j, c_k, \ldots)$ does not
  decrease the value of the expression and returns all values of $f(a_i, b_j,
  c_k, \ldots)$ in ascending order
 - Also add a keyword argument for the other direction
 - Write a similar version for the likes of euler0124.py
